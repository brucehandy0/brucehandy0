{"pages":[{"title":"404","text":"","path":"404/index.html","date":"03-28","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"03-29","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-28","excerpt":""}],"posts":[{"title":"书札","text":"看书最好去图书馆，（相比于在家看）这个用1代表图书馆看书，2代表在家看,1,你付出了1个小时路程的成本，此为付出成本，若此时你想放弃，你还要有1个小时回来的成本，此为放弃成本 1相比2，虽然多付出了2个小时的成本，但是对我效果依然很好 做事有先后，单核效率高","path":"2018/08/20/书札/","date":"08-20","excerpt":""},{"title":"git分支命令简记","text":"创建分支git branch 切换分支git checkout 创建并切换git checkout -b 查看分支git branch查看所有分支 包括远程分支git branch -a 删除分支git push origin –delete","path":"2018/06/25/git分支命令简记/","date":"06-25","excerpt":""},{"title":"mysql按时间查询","text":"mysql mysqldump 只导出表结构 不导出数据:mysqldump –opt -d 数据库名 -u root -p &gt; xxx.sql 导出数据不导出结构:mysqldump -t 数据库名 -uroot -p &gt; xxx.sql 导出数据和表结构:mysqldump 数据库名 -uroot -p &gt; xxx.sql 导出特定表的结构:mysqldump -uroot -p -B 数据库名 –table 表名 &gt; xxx.sql 1）创建个示例表register_order12345678910111213141516171819202122232425262728293031DROP TABLE IF EXISTS `register_order`;/*!40101 SET @saved_cs_client = @@character_set_client */;/*!40101 SET character_set_client = utf8 */;CREATE TABLE `register_order` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `out_refund_no` char(18) NOT NULL COMMENT &apos;退款订单&apos;, `out_trade_no` char(18) NOT NULL COMMENT &apos;订单号&apos;, `total` decimal(10,2) NOT NULL COMMENT &apos;订单金额&apos;, `return_total` decimal(10,2) NOT NULL COMMENT &apos;退款金额&apos;, `return_desc` text COMMENT &apos;退款描述&apos;, `pay_type` varchar(3) NOT NULL COMMENT &apos;支付方式：ali，wc&apos;, `status` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;退款状态: 0未成功，1成功&apos;, `created_at` int(10) NOT NULL COMMENT &apos;创建时间&apos;, `updated_at` int(10) NOT NULL COMMENT &apos;更新时间&apos;,DROP TABLE IF EXISTS `register_order`;/*!40101 SET @saved_cs_client = @@character_set_client */;/*!40101 SET character_set_client = utf8 */;CREATE TABLE `register_order` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `out_refund_no` char(18) NOT NULL COMMENT &apos;退款订单&apos;, `out_trade_no` char(18) NOT NULL COMMENT &apos;订单号&apos;, `total` decimal(10,2) NOT NULL COMMENT &apos;订单金额&apos;, `return_total` decimal(10,2) NOT NULL COMMENT &apos;退款金额&apos;, `return_desc` text COMMENT &apos;退款描述&apos;, `pay_type` varchar(3) NOT NULL COMMENT &apos;支付方式：ali，wc&apos;, `status` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;退款状态: 0未成功，1成功&apos;, `created_at` int(10) NOT NULL COMMENT &apos;创建时间&apos;, `updated_at` int(10) NOT NULL COMMENT &apos;更新时间&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=142 DEFAULT CHARSET=utf8; PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=142 DEFAULT CHARSET=utf8; 2）添加一些数据 3）按时间分类，%d是按天 123$sql = &apos;SELECT DATE_FORMAT(from_unixtime(created_at), &quot;%Y-%m-%d&quot;) as d,sum(return_total) as tFROM register_orderGROUP BY d&apos;; 结果 这个结果不是每天都有，不是我想要的 12345$sql=&apos;select DATE_FORMAT( ADDDATE(&quot;2018-03-01&quot;,INTERVAL @d DAY), &quot;%Y-%m-%d&quot;) as date,@d :=@d + 1 day from register_order,(SELECT @d := 0) tempWHERE ADDDATE(&quot;2018-03-01&quot;,INTERVAL @d DAY) &lt; DATE_FORMAT(&quot;2018-04-01&quot;, &quot;%Y-%m-%d&quot;)GROUP BYdate&apos;; 结果 1234567891011121314$sql = &apos;SELECT A.date ,B.tFROM ( SELECT DATE_FORMAT(ADDDATE(&quot;&apos;.$BeginDate.&apos;&quot;, INTERVAL @d DAY),&quot;%Y-%m-%d&quot;) AS date ,@d :=@d + 1 DAY FROM register_order ,(SELECT @d := 0) tempWHERE ADDDATE(&quot;&apos;.$BeginDate.&apos;&quot;,INTERVAL @d DAY) &lt; DATE_FORMAT(&quot;&apos;.$endDate.&apos;&quot;, &quot;%Y-%m-%d&quot;)) ALEFT JOIN (SELECT DATE_FORMAT(from_unixtime(created_at), &quot;%Y-%m-%d&quot;) as d,ifnull(sum(return_total),0) as tFROM register_orderGROUP BY d) BON A.date = B.d&apos;; 结果 这样终于ok了","path":"2018/05/25/mysql按时间查询/","date":"05-25","excerpt":""},{"title":"window安装elasticsearch","text":"elasticsearch简单理解： index: es里的index相当于一个数据库。 type: 相当于数据库里的一个表。 id： 唯一，相当于主键。 node:节点是es实例，一台机器可以运行多个实例，但是同一台机器上的实例在配置文件中要确保http和tcp端口不同。 cluster:代表一个集群，集群中有多个节点，其中有一个会被选为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。 shards：代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上，构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。 replicas:代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的容错性，当个某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。 环境 系统window，后台php，数据库mysql elasticsearch 到官网下载解压即可，D:\\elasticsearch-6.2.4\\bin\\elasticsearch.bat 启动，在localhost:9200 可以查看是否启动成功 kibana ，是elasticsearch的图形管理工具的网站，到官网下载解压即可启动后，http://localhost:5601可以查看是否启动成功 logstash ，是数据转换工具，用来将数据导入elasticsearch创建logstash.default.conf文件， 123456789input &#123; stdin&#123; &#125;&#125;output &#123; stdout&#123; &#125;&#125; 启动logstash -f logstash_default.conf 安装logstash-input-jdbc参考了https://blog.csdn.net/yowrhihoil/article/details/79568743 mysql-connector-java.jar 自己下载 重新配置logstash.default.conf文件 123456789101112131415161718192021input &#123; jdbc &#123; jdbc_driver_library =&gt; &quot;D:\\logstash-6.2.4\\bin\\lib\\mysql-connector-java-5.1.44-bin.jar&quot; jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/app&quot; jdbc_user =&gt; &quot;root&quot; jdbc_password =&gt; &quot;root&quot; schedule =&gt; &quot;*/2 * * * *&quot; use_column_value =&gt; false tracking_column =&gt; &quot;update_date&quot; statement_filepath =&gt; &quot;D:/logstash-6.2.4/bin/lib/jdbc.sql&quot; &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; [&quot;127.0.0.1:9200&quot;] index =&gt; &quot;app&quot; &#125; stdout&#123; &#125;&#125; sql文件就随便写条查询语句就行 启动logstash，ok composer require elasticsearch/elasticsearch php 调用 elasticsearch 1234567891011$hosts = [ [ &apos;host&apos; =&gt; &apos;localhost&apos; ]];$elastic = Elasticsearch\\ClientBuilder::create()-&gt;setHosts($hosts)-&gt;build();$paras = [ &quot;index&quot;=&gt;&quot;index&quot;, &quot;type&quot;=&gt;&quot;type&quot;];$res = $elastic-&gt;search($paras); linux 环境下安装注意文件权限，端口，ip地址，内存等","path":"2018/05/18/window安装elasticsearch/","date":"05-18","excerpt":""},{"title":"mysql主从复制注意点","text":"2个互相通信的电脑（mysql） 主数据库授予权限GRANT REPLICATION SLAVE ON . TO ‘mysql12’@’192.168.95.12’ IDENTIFIED BY ‘mysql12’; 从数据库实现复制（实际环境不用root账号）change master to master_host=’192.168.1.180’,master_user=’root’,master_password=’root’,master_log_file=’mysql-bin.000002’,master_log_pos=107; master_user 数据库用户master_password 数据库密码 mysql版本5.6是stop slave和start slave不是salve stop SET GLOBAL SQL_SLAVE_SKIP_COUNTER = 1 跳过一个事务 start slave前尽量确保2个数据库的数据一致","path":"2018/04/10/mysql主从复制注意点/","date":"04-10","excerpt":""},{"title":"XDG基本目录规范","text":"XDG基本目录规范 定义 一个规范，用来指定文件和文件格式，文件位置 规范内容 有一个相对于用户特定的数据文件应该写入的基本目录。该目录由环境变量定义$XDG_DATA_HOME。 有一个基本目录相对应用户特定的配置文件应该写入。该目录由环境变量定义$XDG_CONFIG_HOME。 有一组偏好的基本目录，相对于其中的数据文件应该被搜索。这组目录由环境变量定义$XDG_DATA_DIRS。 有一组首选的基本目录相对于哪些配置文件应该被搜索。这组目录由环境变量定义$XDG_CONFIG_DIRS。 有一个单独的基本目录，用户特定的非必要（缓存）数据应该写入其中。该目录由环境变量定义$XDG_CACHE_HOME。 有一个单独的基本目录，用户特定的运行时文件和其他文件对象应放置在该目录中。该目录由环境变量定义$XDG_RUNTIME_DIR。 laravel中xdg的实现代码,（env文件可以定义路径）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class Xdg&#123; const S_IFDIR = 040000; // directory const S_IRWXO = 00007; // rwx other const S_IRWXG = 00056; // rwx group const RUNTIME_DIR_FALLBACK = &apos;php-xdg-runtime-dir-fallback-&apos;; /** * @return string */ public function getHomeDir() &#123; return getenv(&apos;HOME&apos;) ?: (getenv(&apos;HOMEDRIVE&apos;) . DIRECTORY_SEPARATOR . getenv(&apos;HOMEPATH&apos;)); &#125; /** * @return string */ public function getHomeConfigDir() &#123; $path = getenv(&apos;XDG_CONFIG_HOME&apos;) ?: $this-&gt;getHomeDir() . DIRECTORY_SEPARATOR . &apos;.config&apos;; return $path; &#125; /** * @return string */ public function getHomeDataDir() &#123; $path = getenv(&apos;XDG_DATA_HOME&apos;) ?: $this-&gt;getHomeDir() . DIRECTORY_SEPARATOR . &apos;.local&apos; . DIRECTORY_SEPARATOR . &apos;share&apos;; return $path; &#125; /** * @return array */ public function getConfigDirs() &#123; $configDirs = getenv(&apos;XDG_CONFIG_DIRS&apos;) ? explode(&apos;:&apos;, getenv(&apos;XDG_CONFIG_DIRS&apos;)) : array(&apos;/etc/xdg&apos;); $paths = array_merge(array($this-&gt;getHomeConfigDir()), $configDirs); return $paths; &#125; /** * @return array */ public function getDataDirs() &#123; $dataDirs = getenv(&apos;XDG_DATA_DIRS&apos;) ? explode(&apos;:&apos;, getenv(&apos;XDG_DATA_DIRS&apos;)) : array(&apos;/usr/local/share&apos;, &apos;/usr/share&apos;); $paths = array_merge(array($this-&gt;getHomeDataDir()), $dataDirs); return $paths; &#125; /** * @return string */ public function getHomeCacheDir() &#123; $path = getenv(&apos;XDG_CACHE_HOME&apos;) ?: $this-&gt;getHomeDir() . DIRECTORY_SEPARATOR . &apos;.cache&apos;; return $path; &#125; public function getRuntimeDir($strict=true) &#123; if ($runtimeDir = getenv(&apos;XDG_RUNTIME_DIR&apos;)) &#123; return $runtimeDir; &#125; if ($strict) &#123; throw new \\RuntimeException(&apos;XDG_RUNTIME_DIR was not set&apos;); &#125; $fallback = sys_get_temp_dir() . DIRECTORY_SEPARATOR . self::RUNTIME_DIR_FALLBACK . getenv(&apos;USER&apos;); $create = false; if (!is_dir($fallback)) &#123; mkdir($fallback, 0700, true); &#125; $st = lstat($fallback); # The fallback must be a directory if (!$st[&apos;mode&apos;] &amp; self::S_IFDIR) &#123; rmdir($fallback); $create = true; &#125; elseif ($st[&apos;uid&apos;] != getmyuid() || $st[&apos;mode&apos;] &amp; (self::S_IRWXG | self::S_IRWXO) ) &#123; rmdir($fallback); $create = true; &#125; if ($create) &#123; mkdir($fallback, 0700, true); &#125; return $fallback; &#125;&#125; 参考 https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html","path":"2018/04/02/XDG standard/","date":"04-02","excerpt":""},{"title":"微信公众号发送模版消息,错误40001","text":"微信如果手动设置token,token就是固定的，但是很多时候会出意外 比如当微信发送模版消息，会报40001错误，就是token验证不一致，所以非必要情况不建议用手动指定token 微信模版消息中的url参数，不一定非要填‘http://weixin.qq.com/download’， 这个url是指用户点击模版消息时 跳转的地址url","path":"2017/11/29/微信公众号发送模版消息,错误40001/","date":"11-29","excerpt":""},{"title":"PHPMailer修改端口报错","text":"使用的阿里云服务器25端口禁止，所以smtp服务器连接不上，可以换用端口465或994 我的用的163邮箱,详情http://help.163.com/09/1223/14/5R7P3QI100753VB8.html $mail-&gt;Port = 994; $mail-&gt;Host = “ssl://smtp.163.com” 特别注意$mail-&gt;Password不是登录密码，是客户端授权码","path":"2017/11/16/PHPMailer修改端口报错/","date":"11-16","excerpt":""},{"title":"正则知识整理","text":"整理了一些关于正则的知识，不是原创 基础 字符组[] 正则表达式[\\w]+,\\w+,[\\w+] 三者有何区别：[\\w]+和\\w+没有区别，都是匹配数字和字母下划线的多个字符；[\\w+]表示匹配数字、字母、下划线和加号本身字符； ^[^] |[|] [|] 中文[\\u4e00-\\u9fa5] 转义符 \\ 元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述. 查找单个字符，除了换行和行结束符。w 查找单词字符。W 查找非单词字符。d 查找数字。D 查找非数字字符。s 查找空白字符。S 查找非空白字符。b 查找位于单词的开头或结尾的匹配。B 查找不处在单词的开头或结尾的匹配。查找 NUL 字符。n 查找换行符。f 查找换页符。r 查找回车符。t 查找制表符。v 查找垂直制表符。xxx 查找以八进制数 xxx 规定的字符。xdd 查找以十六进制数 dd 规定的字符。uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 \\d 代表[0-9] \\D 代表[^0-9]\\w 代表[0-9a-zA-Z_] \\W 代表[^0-9a-zA-Z_]\\s 代表空白符 \\S 代表非空白符\\n 换行 \\t 制表符（Tab键）\\f 换页符 \\v 垂直制表符[\\b] 退格 注意： \\b是匹配匹配一个词语的边界 量词① {n,m} 最小值—最大值② {n,} 至少n次或者更多次③ {n} 匹配恰好n次 //贪婪模式④ ? 匹配等价于{0,1}⑤ + &gt;=1 等价于{1,}⑥ &gt;=0 等价于{0,}//非贪婪+? ? 表达式修饰符 i 不区分(ignore)大小写；例如: /abc/i 可以匹配 abc、aBC、Abc g 全局(global)匹配如果不带g，正则过程中字符串从左到右匹配，找到第一个符合条件的即匹配成功，返回如果带g，则字符串从左到右，找到每个符合条件的都记录下来，知道字符串结尾位置 可以得到很多结果例如:var str = ‘aaaaaaaa’var reg1 = /a/; str.match(reg1) // 结果为：[“a”, index: 0, input: “aaaaaaaa”]var reg2 = /a/g; str.match(reg2) // 结果为：[“a”, “a”, “a”, “a”, “a”, “a”, “a”, “a”] /m (多行查找) 多行模式/s 单行模式单行模式中;$表示段尾 ,^表示段首 多行模式中:$表示行尾(\\n),^表示每行首 NFA 是 表达式主导引擎， NFA又基本上可以分为传统型NFA和POSIX NFADFA 则是 文本主导引擎 DFA Deterministic finite automaton 确定型有穷自动机 NFA Non-deterministic finite automaton 非确定型有穷自动机 DFA引擎因为不需要回溯，所以匹配快速，但不支持捕获组，所以也就不支持反向引用和$number这种引用方式，目前使用DFA引擎的语言和工具主要有awk、egrep 和 lex。 POSIX NFA主要指符合POSIX标准的NFA引擎，它的特点主要是提供longest-leftmost匹配，也就是在找到最左侧最长匹配之前，它将继续回溯。同DFA一样，非贪婪模式或者说忽略优先量词对于POSIX NFA同样是没有意义的。 大多数语言和工具使用的是传统型的NFA引擎js是传统型NFA 支持()\\1 \\2$1 $2(?:)非捕获1.捕获组、反向引用和$number引用方式； 2.环视(Lookaround，(?&lt;=…)、(?&lt;!…)、(?=…)、(?!…))，或者有的有文章叫做预搜索；前瞻 (?=) 也叫正向零宽先行断言 后面有这个反向前瞻(?!=) 也叫负向零宽先行断言 后面没有这个 后顾(?&lt;=) 正向零宽后行断言 前面有反向后顾(?&lt;！) 前面没有（js不支持后顾） 3.忽略优化量词（??、*?、+?、{m,n}?、{m,}?），或者有的文章叫做非贪婪模式； 匹配优先 忽略优先（贪婪，非贪婪） 4.占有优先量词（?+、*+、++、{m,n}+、{m,}+，目前仅Java和PCRE支持），固化分组(?&gt;…)。 有些流派并不支持占有优先量词和固化分组，比如JavaScript，这是我们就可以用肯定环视来模拟固化分组：?? (?&gt;…) 固化分组(成功匹配后，回簌时不会考虑这个匹配的字符) 效率高 占有字符和零宽度正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的； 如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是零宽度的 占有字符是互斥的，零宽度是非互斥的。 也就是一个字符，同一时间只能由一个子表达式匹配，而一个位置，却可以同时由多个零宽度的子表达式匹配。 正则的匹配过程，通常情况下都是由一个子表达式（可能为一个普通字符、元字符或元字符序列组成）取得控制权，从字符串的某一位置开始尝试匹配，一个子表达式开始尝试匹配的位置，是从前一子表达匹配成功的结束位置开始的。如正则表达式： (子表达式一)(子表达式二) 假设(子表达式一)为零宽度表达式，由于它匹配开始和结束的位置是同一个，如位置0，那么(子表达式二)是从位置0开始尝试匹配的。 假设(子表达式一)为占有字符的表达式，由于它匹配开始和结束的位置不是同一个，如匹配成功开始于位置0，结束于位置2，那么(子表达式二)是从位置2开始尝试匹配的。 javascript只支持零宽先行断言，而零宽先行断言又可以分为正向零宽先行断言，和负向零宽先行断言。代码实例如下:实例代码一:var str=”abZW863”;var reg=/ab(?=[A-Z])/;console.log(str.match(reg));在以上代码中，正则表达式的语义是:匹配后面跟随任意一个大写字母的字符串”ab”。最终匹配结果是”ab”， 因为零宽断言”(?=[A-Z])”并不匹配任何字符，只是用来规定当前位置的后面必须是一个大写字母。 实例代码二var str=”Iraq”;var str=”qoph”; var regex=/q[^u]/ 这里 Irap 不能匹配成功，[^u]需要一个字符，一个不是u的字符， 源字符串：abc 正则表达式：abc 匹配过程： 首先由字符“a”取得控制权，从位置0开始匹配，由“a”来匹配“a”，匹配成功，控制权交给字符“b”；由于“a”已被“a”匹配，所以“b”从位置1开始尝试匹配，由“b”来匹配“b”，匹配成功，控制权交给“c”；由“c”来匹配“c”，匹配成功。 此时正则表达式匹配完成，报告匹配成功。匹配结果为“abc”，开始位置为0，结束位置为3。 源字符串：a12 正则表达式：^(?=[a-z])[a-z0-9]+$ 元字符“^”和“$”匹配的只是位置，顺序环视“(?=[a-z])”只进行匹配，并不占有字符，也不将匹配的内容保存到最终的匹配结果，所以都是零宽度的。 这个正则的意义就是匹配由字母和数字组成的，第一个字符是字母的字符串。 匹配过程： 首先由元字符“^”取得控制权，从位置0开始匹配，“^”匹配的就是开始位置“位置0”，匹配成功，控制权交给顺序环视“(?=[a-z])”； “(?=[a-z])”要求它所在位置右侧必须是字母才能匹配成功，零宽度的子表达式之间是不互斥的，即同一个位置可以同时由多个零宽度子表达式匹配，所以它也是从位置0尝试进行匹配，位置0的右侧是字符“a”，符合要求，匹配成功，控制权交给“[a-z0-9]+”； 因为“(?=[a-z])”只进行匹配，并不将匹配到的内容保存到最后结果，并且“(?=[a-z])”匹配成功的位置是位置0，所以“[a-z0-9]+”也是从位置0开始尝试匹配的，“[a-z0-9]+”首先尝试匹配“a”，匹配成功，继续尝试匹配，可以成功匹配接下来的“1”和“2”，此时已经匹配到位置3，位置3的右侧已没有字符，这时会把控制权交给“$”； 元字符“$”从位置3开始尝试匹配，它匹配的是结束位置，也就是“位置3”，匹配成功。 此时正则表达式匹配完成，报告匹配成功。匹配结果为“a12”，开始位置为0，结束位置为3。其中“^”匹配位置0，“(?=[a-z])”匹配位置0，“[a-z0-9]+”匹配字符串“a12”，“$”匹配位置3。 校验： 汉字之间不允许有空格；英文名字母中间只允许有1个空格；汉字与符号之间，字母与符号之间不允许有空格。 “•”或“_”或“-”只能出现在两个汉字或两个字母之间，两个汉字或两个字母之间只允许有1个符号。 仅可以为汉字、字母以及汉字与符号的组合、字母与符号的组合，符号仅允许下列符号“•”（ GB13000编码为00B7，GB18030编码为A1A4）或“” 或“-”或空格(“” 或“-”或空格仅允许半角模式)。 必须大于等于2个字符,小于等于50个字符 （一个字符就是一个字、字母） var userName_regex = /^((([\\u4E00-\\u9FA5\\uf900-\\ufa2d])([\\u4E00-\\u9FA5\\uf900-\\ufa2d]|_(?!_|-|·)|-(?!_|-|·)|·(?!_|-|·)){0,48}([\\u4E00-\\u9FA5\\uf900-\\ufa2d])$)|(([a-zA-Z])([a-zA-Z]|\\s(?!_|-|·|\\s)|_(?!_|-|·|\\s)|-(?!_|-|·|\\s)|·(?!_|-|·|\\s)){0,48})([a-zA-Z])$)$/; var userName_regex = /^((([\\u4E00-\\u9FA5\\uf900-\\ufa2d]) ([\\u4E00-\\u9FA5\\uf900-\\ufa2d] | _(?!_|-|·)|-(?!_|-|·)|·(?!_|-|·)){0,48} ([\\u4E00-\\u9FA5\\uf900-\\ufa2d]) $) | (([a-zA-Z])([a-zA-Z]|\\s(?!_|-|·|\\s)|_(?!_|-|·|\\s)|-(?!_|-|·|\\s)|·(?!_|-|·|\\s)){0,48})([a-zA-Z])$)$/ ; var s = ‘by Jeffrey Friedl’var s = ‘by Thomas Jefferson’var r=/(?=Jeffrey)Jeff/ var s=’123456789’;任务 改造成’123,456,789’ var r=/(?&lt;=\\d&gt;)(?=\\d\\d\\d)/,/g ||||| 效率很低 什么是贪婪与非贪婪模式 源字符串：abc 正则表达式：ab?c 匹配优先忽略优先 量词“?”属于匹配优先量词，在可匹配可不匹配时，会先选择尝试匹配，只有这种选择会使整个表达式无法匹配成功时，才会尝试让出匹配到的内容。这里的量词“?”是用来修饰字符“b”的，所以“b?”是一个整体。 匹配过程： 首先由字符“a”取得控制权，从位置0开始匹配，由“a”来匹配“a”，匹配成功，控制权交给字符“b?”；由于“?”是匹配优先量词，所以会先尝试进行匹配，由“b?”来匹配“b”，匹配成功，控制权交给“c”，同时记录一个备选状态；由“c”来匹配“c”，匹配成功。记录的备选状态丢弃。 此时正则表达式匹配完成，报告匹配成功。匹配结果为“abc”，开始位置为0，结束位置为3。 源字符串：ac 正则表达式：ab?c 匹配过程： 首先由字符“a”取得控制权，从位置0开始匹配，由“a”来匹配“a”，匹配成功，控制权交给字符“b?”；先尝试进行匹配，由“b?”来匹配“c”，同时记录一个备选状态，匹配失败，此时进行回溯，找到备选状态，“b?”忽略匹配，让出控制权，把控制权交给“c”；由“c”来匹配“c”，匹配成功。 源字符串：abc正则表达式：ab??c 量词“??”属于忽略优先量词，在可匹配可不匹配时，会先选择不匹配，只有这种选择会使整个表达式无法匹配成功时，才会尝试进行匹配。这里的量词“??”是用来修饰字符“b”的，所以“b??”是一个整体。 匹配过程： 首先由字符“a”取得控制权，从位置0开始匹配，由“a”来匹配“a”，匹配成功，控制权交给字符“b??”；先尝试忽略匹配，即“b??”不进行匹配，同时记录一个备选状态，控制权交给“c”；由“c”来匹配“b”，匹配失败，此时进行回溯，找到记录的备选状态，“b??”尝试匹配，即“b??”来匹配“b”，匹配成功，把控制权交给“c”；由“c”来匹配“c”，匹配成功。 此时正则表达式匹配完成，报告匹配成功。匹配结果为“abc”，开始位置为0，结束位置为3。其中“b??”匹配字符“b”。 先看一个例子 举例： 源字符串：aatest1bbtest2cc 正则表达式一：.* 匹配结果一：test1bbtest2 正则表达式二：.*? 匹配结果二：test1（这里指的是一次匹配结果，所以没包括test2） 在“整个表达式匹配成功”的前提下，贪婪模式才真正的影响着子表达式的匹配行为，如果整个表达式匹配失败，贪婪模式只会影响匹配过程，对匹配结果的影响无从谈起。 源字符串：”Regex” 正则表达式：”.“贪婪来看一下匹配过程。首先由第一个“””取得控制权，匹配位置0位的“””，匹配成功，控制权交给“.”。 “.”取得控制权后，由于“”是匹配优先量词，在可匹配可不匹配的情况下，优先尝试匹配。从位置1处的“R”开始尝试匹配，匹配成功，继续向右匹配，匹配位置2处的“e”，匹配成功，继续向右匹配，直到匹配到结尾的“””，匹配成功，由于此时已匹配到字符串的结尾，所以“.*”结束匹配，将控制权交给正则表达式最后的“””。 “””取得控制权后，由于已经在字符串结束位置，匹配失败，向前查找可供回溯的状态，控制权交给“.”，由“.”让出一个字符，也就是字符串结尾处的“””，再把控制权交给正则表达式最后的“””，由“””匹配字符串结尾处的“””，匹配成功。 此时整个正则表达式匹配成功，其中“.*”匹配的内容为“Regex”，匹配过程中进行了一次回溯。 正则表达式：”.*?” “.?”取得控制权后，由于“?”是忽略优先量词，在可匹配可不匹配的情况下，优先尝试不匹配，由于“*”等价于“{0,}”，所以在忽略优先的情况下，可以不匹配任何内容。从位置1处尝试忽略匹配，也就是不匹配任何内容，将控制权交给正则表达式最后的“””。 “””取得控制权后，从位置1处尝试匹配，由“””匹配位置1处的“R”，匹配失败，向前查找可供回溯的状态，控制权交给“.?”，由“.?”吃进一个字符，匹配位置1处的“R”，再把控制权交给正则表达式最后的“””。 “””取得控制权后，从位置2处尝试匹配，由“””匹配位置1处的“e”，匹配失败，向前查找可供回溯的状态，重复以上过程，直到由“.*?”匹配到“x”为止，再把控制权交给正则表达式最后的“””。 “””取得控制权后，从位置6处尝试匹配，由“””匹配字符串最后的“””，匹配成功。 此时整个正则表达式匹配成功，其中“.*?”匹配的内容为“Regex”，匹配过程中进行了五次回溯。 贪婪模式还有一点优势，就是在匹配失败时，贪婪模式可以更快速的报告失败，从而提升匹配效率 总结 能达到同样匹配结果的贪婪与非贪婪模式，通常是贪婪模式的匹配效率较高。 所有的非贪婪模式，都可以通过修改量词修饰的子表达式，转换为贪婪模式。 贪婪模式可以与固化分组结合，提升匹配效率，而非贪婪模式却不可以。 固话分组“(?&gt;[^”]*)”","path":"2017/08/12/正则/","date":"08-12","excerpt":""},{"title":"CentOS 7 安装ffmpeg","text":"CentOS 7 安装ffmpeg安装EPEL Release，因为安装需要使用其他的repo源，所以需要EPEL支持yum install -y epel-release 如果出现缺少Code提示，可以： sudo rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7 安装完成之后，可以查看是否安装成功 yum repolist 安装Nux-Dextop源导入一个Codesudo rpm –import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro安装nux-dextop 源sudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el.nux.noarch.rpm查看repo源是否安装成功yum repolist yum安装ffmpegyum install -y ffmpeg安装完成后检查ffmpeg 版本ffmpeg -version CentOS 6和7安装方法是不一样的，下面分别说明： 安装前都需要先安装epel扩展源 yum -y install epel-release CentOS 6比较简单，安装yum源之后直接安装即可： su -c ‘yum localinstall –nogpgcheck https://download1.rpmfusion.org/free/el/rpmfusion-free-release-6.noarch.rpm https://download1.rpmfusion.org/nonfree/el/rpmfusion-nonfree-release-6.noarch.rpm‘ yum -y install ffmpeg ffmpeg-devel ffmpeg基本命令分离视频音频流 ffmpeg -i input_file -vcodec copy -an output_file_video //分离视频流ffmpeg -i input_file -acodec copy -vn output_file_audio //分离音频流 视频解复用 ffmpeg –i test.mp4 –vcodec copy –an –f m4v test.264ffmpeg –i test.avi –vcodec copy –an –f m4v test.264 视频转码 ffmpeg –i test.mp4 –vcodec h264 –s 352278 –an –f m4v test.264 //转码为码流原始文件ffmpeg –i test.mp4 –vcodec h264 –bf 0 –g 25 –s 352278 –an –f m4v test.264 //转码为码流原始文件ffmpeg –i test.avi -vcodec mpeg4 –vtag xvid –qsame test_xvid.avi //转码为封装文件//-bf B帧数目控制，-g 关键帧间隔控制，-s 分辨率控制 视频封装 ffmpeg –i video_file –i audio_file –vcodec copy –acodec copy output_file 视频剪切 ffmpeg –i test.avi –r 1 –f image2 image-%3d.jpeg //提取图片ffmpeg -ss 0:1:30 -t 0:0:20 -i input.avi -vcodec copy -acodec copy output.avi //剪切视频 ffmpeg -ss 0:0:0 -t 0:0:20 -i /var/www/html/2.mp4 -vcodec copy -acodec copy /var/www/html/output.mp4 //-r 提取图像的频率，-ss 开始时间，-t 持续时间 视频录制 ffmpeg –i rtsp://192.168.3.205:5555/test –vcodec copy out.avi YUV序列播放 ffplay -f rawvideo -video_size 1920x1080 input.yuv YUV序列转AVI ffmpeg –s w*h –pix_fmt yuv420p –i input.yuv –vcodec mpeg4 output.avi","path":"2017/05/29/CentOS 7 安装ffmpeg/","date":"05-29","excerpt":""},{"title":"js单例模式","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//单例模式1var mySingleton = &#123; name:’songjiang’, age:’45’, run:function()&#123; // &#125;&#125;//单例模式2，var mySingleton2 = function()&#123;//私有var instantiated;var privateVariable = ‘v’;function walk()&#123;&#125;;//公有if(!instantiated)&#123; instantiated = &#123; publicV : ‘pv’, publicMethod:function()&#123; console.log(privateVariable); &#125; &#125;&#125;return instantiated;&#125;//单例模式3 只有当使用时才会初始化var mySingleton3 = (function()&#123; var instantiated ; //主体 function init()&#123; return&#123; publicMethod:function()&#123; &#125;, publicV:’v’, &#125; &#125; return &#123; getInstance:function()&#123; if(!instantiated)&#123; insantiated = init(); &#125; return insantiated; &#125; &#125;&#125;)();","path":"2017/03/14/js单例模式/","date":"03-14","excerpt":""},{"title":"hexo修改默认端口","text":"本机的4000端口被占用了，用hexo s -p 80 ，可以暂时修改启动端口，但是每次启动都要写-p 80，很不爽， 我安装的hexo版本是3.2.2，找到node_modules\\hexo-server\\index.js文件，可以修改默认的port值 部署中我遇到的一些问题部署到github上,建立的库的名字要注意yml格式_config.yml文件的deploy:type: git _config.yml文件的url和root字段，我的是这样的url: https://brucehandy0.github.ioroot: /","path":"2017/03/14/hexo修改默认端口/","date":"03-14","excerpt":""},{"title":"js中的length","text":"数组和集合都有length属性，我们常常用length来遍历它们 注意一下length，length的值变量，取length值时每次都检测length的是多少， 如果在遍历时添加数据，很有可能造成死循环12345var alldivs = document.getElementsByTagName(‘div’);for (var i = 0; i &lt; alldivs.length; i++) &#123; console.log(alldivs); //document.body.appendChild(document.createElement(‘div’))&#125; 死循环 可以用一个变量len,由于只赋值一次，即时length的值变化，len也是固定的12345678var arr = [];arr[0] = 0;arr[1] = 1;var len = arr.length;for(var i=0;i&lt;len;i++)&#123; console.log(arr); arr.push(1);&#125; ok","path":"2016/12/05/js中的length/","date":"12-05","excerpt":""},{"title":"autohotkey 改建","text":"昨天码字时，感到有些不舒畅，比如上下左右键好远，我想把=换成 = 的风格等等， 遂接触了autohotkey，感觉还不错的,给大家安利一下（当然不止是这一点点的好处啦） 我的codestyle.ahk代码 ;RCtrl replace right+;+enter ，按下右边ctrl等同 右+分号+回车 三键RCtrl::{Send,{Right}{`;}{Enter}return} ; = replace space+=+space~LAlt &amp; =::{Send,{Space}{`=}{Space}return};RAlt &amp; w::{Send,{Up}return}RAlt &amp; s::{Send,{Down}return}RAlt &amp; a::{Send,{Left}return}RAlt &amp; d::{Send,{Right}return}","path":"2016/10/27/autohotkey 改建/","date":"10-27","excerpt":""},{"title":"js简易实现private,public,static和继承","text":"12345678910111213141516171819202122232425262728293031323334js实现private，public，static和继承 ///构造函数function person()&#123; this.name = ‘’;//这个相当于public var age =12;//private //不建议每个函数都用this.getAge，浪费内存， //但是对于私有变量age只能用this.getAge来获取值 this.getAge = function()&#123; return age; &#125;;&#125;//添加静态属性或方法person.TYPE = ‘people’;person.sayHello = function()&#123; console.log(‘hello world’);&#125;//类的public方法person.prototype.setName=function(name)&#123; this.name = name;&#125;person.prototype.getName=function()&#123; return this.name;&#125;person.prototype.setAge = function(age)&#123; this.age = age;&#125;var p = new person();p.setName(‘lili’);p.setAge(45);//静态类var staticClass = &#123;&#125;","path":"2016/10/09/js简易实现private,public,static和继承/","date":"10-09","excerpt":""},{"title":"js常用函数的封装","text":"整理我的常用封装函数//检测数据类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171function chechOutType(obj)&#123; var o = Object.prototype.toString.apply(obj); switch(o)&#123; case &apos;[object Function]&apos;: o = &apos;isfunction&apos;; break; case &apos;[object Object]&apos;: o = &apos;isObject&apos;; break; case &apos;[object RegExp]&apos;: o = &apos;isRegExp&apos;; break; case &apos;[object Array]&apos;: o = &apos;isArray&apos;; break; //这个未检测 case &apos;[object JSON]&apos;: o = &apos;isJSON&apos;; break; case &apos;[object String]&apos;: o = &apos;isString&apos;; break; case &apos;[object Number]&apos;: o = &apos;isNumber&apos;; break; case &apos;[object Boolean]&apos;: o = &apos;isBoolean&apos;; break; //这个不常用，webgl会涉及 case &apos;[object ArrayBuffer]&apos;: o = &apos;isArrayBuffer&apos; break; default: alert(&quot;not of them&quot;); &#125; return o;&#125;;//另一种写法 var type = function(o)&#123; var s = Object.prototype.toString.apply(o); return s.match(/\\[object (.*?)\\]/)[1].toLowerCase(); &#125; var array=[&apos;Null&apos;,&apos;Undefined&apos;,&apos;Object&apos;,&apos;Array&apos;,&apos;String&apos;,&apos;Number&apos;,&apos;Boolean&apos;,&apos;Function&apos;,&apos;RegExp&apos;,&apos;NaN&apos;,&apos;Infinite&apos;]; array.forEach(function(t)&#123; type[&quot;is&quot;+t] = function(o)&#123; return type(o) === t.toLowerCase(); &#125; &#125;); var a=54; console.log(type.isArray(a));`&lt;/pre&gt;//添加事件监听&lt;pre&gt;`function addEventHandler(target,type,func)&#123; if(target.addEventListener)&#123; target.addEventListener(type, func, false); &#125;else if(target.attachEvent)&#123; target.attachEvent(&quot;on&quot; + type, func); &#125;else&#123; target[&quot;on&quot; + type] = func; &#125; &#125;`&lt;/pre&gt;//得到style&lt;pre&gt;` function getstyle(obj,name)&#123; if(obj.currentStyle)&#123; return obj.currentStyle[name]; &#125;else&#123; return getComputedStyle(obj,false)[name]; &#125; &#125;`&lt;/pre&gt;//自己常用&lt;pre&gt;`function con(obj,type)&#123; type = type||&apos;l&apos;; switch(type)&#123; case &apos;l&apos;: console.log(obj); break; case &apos;i&apos;: console.info(obj); break; case &apos;e&apos;: console.error(obj); break; case &apos;d&apos;: console.debug(obj); break; case &apos;w&apos;: console.warn(obj); break; case &apos;dir&apos;: console.dir(obj); break; case &apos;assert&apos;: console.assert(obj); break; case &apos;trace&apos;: console.trace(obj); break; &#125;&#125;`&lt;/pre&gt;//通过类名查找元素，但是要给定一个父元素&lt;pre&gt;`function getElementsByClass(oParent, target) &#123; var aEle = oParent.getElementsByTagName(&apos;*&apos;); var aResult = []; var reg = new RegExp(&apos;\\\\b&apos; + target + &apos;\\\\b&apos;, &apos;i&apos;); console.info(reg); var i = 0; for(i = 0; i &amp;lt; aEle.length; i++) &#123; if(reg.test(aEle[i].className)) &#123; aResult.push(aEle[i]); &#125; &#125; return aResult;&#125;function myQuery(obj)&#123; //保存符合条件的子元素 this.children=[]; switch(typeof obj)&#123; case &apos;function&apos;: //函数 addEventHandler(window,&apos;load&apos;,obj); break; case &apos;string&apos;: var objWithoutInitial = obj.substring(1); switch(obj.charAt(0))&#123; case &apos;#&apos;: //id选择器 var o = document.getElementById(objWithoutInitial); this.children.push(o); break; case &apos;.&apos;: //类选择器 this.children = getElementsByClass(document,objWithoutInitial); break; default: //tag元素选择器 this.children =document.getElementsByTagName(obj); &#125; break; case &apos;object&apos;: this.children.push(obj); break; default: alert(&apos;不支持此用法&apos;); &#125;&#125;function $(obj)&#123; return new myQuery(obj);&#125;//实现数组换行显示，,默认每十行一换行，未实现等距输出function showArray(arr,len)&#123; len = len|10; var showArr = arr; for(var i=0;i&lt;(arr.length/len);i++)&#123; showArr = arr.slice(0+len*i,len+len*i); console.log(showArr); &#125;&#125;","path":"2016/09/10/js常用函数的封装/","date":"09-10","excerpt":""},{"title":"win下开机启动软件","text":"脚本呢，就是因为有的人很懒，懒得去做重复的事情所以拿脚本来代替自己做重复的事情， 今天想开机启动一些软件，但是在软件的设置中是没有找到开机启动的设置怎么办呢，想到bat文件有操作系统（window系统）的功能查一查ok get it第一步 启动一个程序start “D:\\Program Files (x86)\\Notepad++\\notepad++.exe”这个是bat文件 启动一个软件的代码怎么不行 ，路径名中带有空格的话 要这样写start “” “D:\\Program Files (x86)\\Notepad++\\notepad++.exe”路径名中有中文字符呢 将文件格式改为ansi格式就ok了 第二步 开机启动我的操作系统是win8的，下面这个就启动项文件夹C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp将bat文件放到这个文件夹下就ok了 最小化启动 start /min “” “C:\\Users\\li\\AppData\\Local\\Wunderlist\\Wunderlist.exe”","path":"2016/09/04/win下开机启动软件/","date":"09-04","excerpt":""},{"title":"git常用命令","text":"git init // git c创建库 git remote add origin https://gitee.com/brucehandy357/test.git // git远程连接 git add readme.txt git commit -m “wrote a readme file” git push -u origin master加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 git push origin master git pull 时版本冲突 放弃本地修改，直接覆盖之 git reset –hard git pull 查名字git config user.name git config –list 或者查看~/.gitconfig文件。 改名字：git config –global user.name “Furzoom”# orvi ~/.gitconfig 配置git服务器 要点git跟svn不同的是 ，git是分布式， 即每一个git仓库都可以成为git服务器 因为一般在linux下配置要创建一个用户 ，一个用户组 等 初始化 git仓库，git init test.git 把仓库的分配给 git用户 .git config配置文件添加 可以从远程接受提交[receive]denyCurrentBranch = ignore 设置git服务器，当文件变动时自动更新， gitblitgit服务器的图形界面的工具 详情http://blog.csdn.net/u012606648/article/details/52514745?readlog","path":"2016/06/12/git常用命令/","date":"06-12","excerpt":""},{"title":"backbone入门学习","text":"这几天初学Backbone.js,（下文简称bbjs）学到的几点心得总结一下： 适用范围：重客户端站点，服务端只提供json。 特点：bbjs是一个前段js的muc框架，（与bootstrap，jquery一起食用味道更佳），数据（model）和展示（view）分离 bbjs下层依赖underscore.js。 bbjs主要包括model，collection，view，router，history,还有模板的运用, 模板挺好用的,前期主要难点在view视图的render(); 比angular.js好学，但是学习材料较少（国内） 学习链接：underscore.js中文文档 Backbone.js中文文档(未完全翻译)","path":"2015/12/29/backbone入门学习/","date":"12-29","excerpt":""},{"title":"jdk高版本不能覆盖低版本怎么办","text":"今天碰到 unsupportedclassversionerror 这个异常，查一查知道，jdk不能从高版本转到低版本， 以前安装的是jdk1.7，现在我用的是jdk1.8，但是cmd窗口的java -verison 还是1.7 原因 在安装JDK1.7时（本机先安装jdk1.7再安装的jdk1.8），自动将java.exe、javaw.exe、javaws.exe三个可执行文件复制到了C:\\Windows\\System32目录，由于这个目录在WINDOWS环境变量中的优先级高于JAVA_HOME设置的环境变量优先级 解决方案：将java.exe,javaw.exe,javaws.exe删除即可。开启新的命令行窗口，再执行java -version时，就得到了期望中的结果 现在解决 参考资料; http://luohaiyong1024.blog.163.com/blog/static/2682797201231104615287/","path":"2015/11/09/jdk高版本不能覆盖低版本怎么办/","date":"11-09","excerpt":""}]}